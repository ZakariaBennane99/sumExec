// this is to read environment variables
require('dotenv').config()
const jwt = require("jsonwebtoken")
const express = require("express")
const router = express.Router()
const auth = require("../middleware/auth")
const User = require("../models/User")
const { check, validationResult } = require('express-validator')
const bcrypt = require("bcrypt")
const fs = require("fs")
const { use } = require('./profile')


// @route   POST api/auth
// @desc    Authenticate user
// @access  Public

router.post(
    '/',
    [
        check("email", "Please include a valid email").isEmail(),
        check("password", "Password is required").not().isEmpty()
    ],
    async (req, res) => {
        const errors = validationResult(req)
        if (!errors.isEmpty()) {
            res.status(400).json({ errors: errors.array() })
            return
        }

        // destructuring the request
        const { email, password } = req.body

        function capitalize(s) {
            return s[0].toUpperCase() + s.slice(1)
        }

        try {
            let user = await User.findOne({ email })
            // if the user doesn't exists
            if (!user) {
                res.status(401).json({ errors: [{ msg: "Invalid Credentials" }] })
                return
            }

            const isMatch = await bcrypt.compareSync(password, user.password)

            if (!isMatch) {
                // for security reasons (the user doesn't exists or the password is incorrect)
                // it is good to send the same error message
                res.status(401).json({ errors: [{ msg: "Invalid Credentials" }] })
                return
            }

            function getUserImgs() {

                try {
                    // first check if the URL exists in the servr
                    const coURI = `users_images/${user.id}/Cover`
                    const avURI = `users_images/${user.id}/Avatar`
                    // read binary data
                    const avBitmap = fs.readFileSync(avURI)
                    const coBitmap = fs.readFileSync(coURI)
                    // convert binary data to base64 encoded string
                    const avBase64 =  new Buffer(avBitmap).toString('base64')
                    const coBase64 =  new Buffer(coBitmap).toString('base64')
                    const imgs = [{
                        type: user.cover.name,
                        extension: user.cover.extension,
                        img: coBase64
                    }, {
                        type: user.avatar.name,
                        extension: user.avatar.extension,
                        img: avBase64
                    }]
                    return { status: 200, imgsUrl: imgs }
                } catch (err) {
                    console.log(err.message)
                    return { status: 404 }
                }

            }

            // check if verified
            if (user.verified) {
                /// return jsonwebtoken to be used with protected routes ///
                const payload = {
                    user: {
                        // the id is automatically generated by MongoDB
                        id: user.id
                    }
                }

                const rImgs = getUserImgs()


                // the following will return a token generated for the user
                jwt.sign(payload,
                    process.env.USER_JWT_SECRET,
                    // ! Do Not Forget To transform it Back To 3600s In Production
                    { expiresIn: 3600 },
                    (err, token) => {
                        if (err) throw err
                        const s = {
                            token: token,
                            userData: {
                                fullName: capitalize(user.fName)  + " " + capitalize(user.lName),
                                email: user.email,
                                imgs: rImgs,
                                id: user.id
                            }
                        }
                        res.status(201).json(s)
                        return
                    })
            } else {
                res.status(403).json({ errors: [{ msg: "Email Unverified" }] })
                return
            }

        } catch(err) {
            console.error(err.message)
            res.status(500).send("Server Error")
            return
        }
})


// @route   POST api/auth/checkToken
// @desc    Check if the user's token still valid
// @access  Public

router.post('/checkToken', async (req, res) => {
        // get the token from the header
        const token = req.header("x-auth-token")

        try {
            // check if no token
            if (!token) {
                // 401 means not authorized
                res.status(404).json({ msg: "No token" })
                return
            }

            // verify token
            try {
                const decoded = jwt.verify(token, process.env.USER_JWT_SECRET)
                // setting the user who sends the request to decoded.user
                // which is basically the user associated with the token
                res.status(200).json({ msg: "Token is verified", userID: decoded.user })
                return
            } catch(err) {
                res.status(401).json({ msg: "Your Session Has Expired, Please Sign In Again!" })
                return
            }
        } catch(err) {
            console.log(err)
            res.status(500).json({ msg: 'Server error' })
            return
        }
})


module.exports = router
